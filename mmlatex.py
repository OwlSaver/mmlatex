import re
import sys
import argparse
import math

# --- Configuration (Used as defaults for CLI) ---
INPUT_FILE = "map_data.txt"
OUTPUT_FILE = "project_mindmap.tex"
INDENT_SPACES = 2 # Number of spaces per indentation level

# Pre-defined angles for Level 1 branches to ensure an aesthetically pleasing cyclic layout
# Angles are in degrees (0 = right, 90 = up, 180 = left, 270 = down)
LEVEL_1_ANGLES = [150, 30, 270, 210, 90, 330]

# --- LaTeX Template Sections ---

LATEX_START = r"""
\documentclass[11pt, a4paper]{article}
\usepackage[a4paper, margin=1in]{geometry}
\usepackage{tikz}
\usepackage{fontspec}
\usepackage[english]{babel}

% Use Noto Sans for clean, modern look
\babelfont{rm}{Noto Sans} 

\usetikzlibrary{mindmap, trees, shadows}

\pagestyle{empty} % Remove page numbers

\begin{document}
\centering
\section*{Project Phases Mind Map}

\begin{tikzpicture}[
    mindmap,
    grow cyclic, % Automatically space nodes in a circle
    text=white,
    % Overall concept color for the central node
    concept color=blue!70!black, 
    
    % Style definitions for various levels
    every node/.style={concept, minimum width=2.5cm, align=center, font=\large},
    
    level 1 concept/.append style={
        level distance=4cm, 
        sibling angle=120, 
        concept color=red!70, 
        font=\Large\bfseries
    },
    
    level 2 concept/.append style={
        level distance=3.5cm, 
        sibling angle=60, 
        concept color=orange!70,
        font=\large\sffamily
    },
    
    level 3 concept/.append style={
        level distance=3cm, 
        sibling angle=45, 
        concept color=green!70!black,
        font=\small\sffamily
    },
]

  % START OF TIKZ NODES GENERATED BY PYTHON
  % Level 0 node is the central node
  \node[concept] { \textbf{Project} \par \textbf{Phases} }
"""

LATEX_END = r"""
  ; % End of the main node structure

\end{tikzpicture}

\vspace{0.5in}
\footnotesize
\textit{This mind map was generated from an indented text file using a Python script.}

\end{document}
"""

def get_indentation_level(line):
    """Calculates the indentation level based on spaces."""
    leading_spaces = len(line) - len(line.lstrip(' '))
    # Integer division to find the level
    return leading_spaces // INDENT_SPACES

def generate_tikz_code(lines):
    """Reads the list of lines and generates the TikZ node structure."""
    
    tikz_nodes = []
    current_depth = 0 
    angle_index = 0
    
    # We skip the first line (Level 0) as it is already defined in LATEX_START
    lines_to_process = lines[1:] if lines else [] 

    for line in lines_to_process:
        line = line.rstrip() # Remove trailing whitespace (including newline)
        
        if not line.strip():
            continue # Skip empty lines

        depth = get_indentation_level(line)
        concept_text = line.strip()
        
        # If we encounter a shallower level, close the previous child nodes
        if depth < current_depth:
            levels_to_pop = current_depth - depth
            tikz_nodes.append("  " * depth + "} " * levels_to_pop + "\n")
        
        # Determine the appropriate opening structure
        if depth > 0:
            
            # For Level 1, apply the custom grow angle
            if depth == 1:
                angle = LEVEL_1_ANGLES[angle_index % len(LEVEL_1_ANGLES)]
                tikz_nodes.append(f"  " * depth + f"child[grow={angle}] {{\n")
                angle_index += 1
            else:
                # For deeper levels, just use the standard child command
                tikz_nodes.append(f"  " * depth + "child {\n")
                
            # Add the concept node itself
            tikz_nodes.append(f"  " * (depth + 1) + f"\\node[concept] {{{concept_text}}}")
            
        current_depth = depth

    # After the loop, close any remaining open child nodes
    if current_depth > 0:
        # We need to close from the max depth back to level 1
        tikz_nodes.append("} " * current_depth) 
        
    # Join all the parts together
    tikz_code_body = "".join(tikz_nodes)
    
    return f"{LATEX_START}{tikz_code_body}{LATEX_END}"

def main():
    """Main function to handle CLI arguments and perform I/O."""
    parser = argparse.ArgumentParser(
        description="Convert an indented text outline to a TikZ mind map LaTeX document.",
        epilog=f"Usage examples: \n  python {sys.argv[0]} -i input.txt -o output.tex\n  cat input.txt | python {sys.argv[0]} -i - -o -"
    )
    parser.add_argument('-i', '--input', type=str, default=INPUT_FILE,
                        help=f"Input file path (default: {INPUT_FILE}). Use '-' for standard input.")
    parser.add_argument('-o', '--output', type=str, default=OUTPUT_FILE,
                        help=f"Output file path (default: {OUTPUT_FILE}). Use '-' for standard output.")
    args = parser.parse_args()

    # --- Read Input ---
    input_lines = []
    if args.input == '-':
        print("Reading from standard input (stdin)...", file=sys.stderr)
        try:
            input_lines = sys.stdin.readlines()
        except Exception as e:
            print(f"Error reading from stdin: {e}", file=sys.stderr)
            sys.exit(1)
    else:
        try:
            with open(args.input, 'r') as f:
                print(f"Reading from file: {args.input}", file=sys.stderr)
                input_lines = f.readlines()
        except FileNotFoundError:
            print(f"Error: Input file '{args.input}' not found.", file=sys.stderr)
            sys.exit(1)
        except Exception as e:
            print(f"Error reading file '{args.input}': {e}", file=sys.stderr)
            sys.exit(1)

    # --- Generation ---
    if not input_lines:
        print("Warning: Input is empty. Generating an empty map.", file=sys.stderr)
        # Still generate the boilerplate document
        full_latex_document = f"{LATEX_START}{LATEX_END}" 
    else:
        full_latex_document = generate_tikz_code(input_lines)

    # --- Write Output ---
    if args.output == '-':
        # Write directly to stdout
        sys.stdout.write(full_latex_document)
    else:
        try:
            with open(args.output, 'w') as f:
                f.write(full_latex_document)
            print(f"Successfully generated LaTeX document: {args.output}", file=sys.stderr)
        except IOError:
            print(f"Error: Could not write to output file '{args.output}'.", file=sys.stderr)
            sys.exit(1)

if __name__ == "__main__":
    main()