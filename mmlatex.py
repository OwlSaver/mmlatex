import re
import sys
import argparse
import math

# --- Configuration (Used as defaults for CLI) ---
INPUT_FILE = "map_data.txt"
OUTPUT_FILE = "project_mindmap.tex"
INDENT_SPACES = 4 # UPDATED: Number of spaces per indentation level is now 4

# Pre-defined angles for Level 1 branches to ensure an aesthetically pleasing cyclic layout
LEVEL_1_ANGLES = [150, 30, 270, 210, 90, 330]

# --- LaTeX Template Sections ---

# Note: LATEX_START and LATEX_END now use placeholders for dynamic content.

LATEX_START_TEMPLATE = r"""
\documentclass[11pt, a4paper]{article}
\usepackage[a4paper, margin=1in]{geometry}
\usepackage{tikz}
\usepackage{fontspec}
\usepackage[english]{babel}
\usepackage{longtable} % NEW: Required for long tables
\usepackage{booktabs}  % NEW: For nice table rules (toprule, midrule, bottomrule)

% Use Noto Sans for clean, modern look
\babelfont{rm}{Noto Sans} 

\usetikzlibrary{mindmap, trees, shadows}

\pagestyle{empty} % Remove page numbers

\begin{document}
\centering
\section*{Project Phases Mind Map}

\begin{tikzpicture}[
    mindmap,
    grow cyclic, % Automatically space nodes in a circle
    text=white,
    % Overall concept color for the central node
    concept color=blue!70!black, 
    % Style definitions for various levels
    every node/.style={concept, minimum width=2.5cm, align=center, font=\large},
    level 1 concept/.append style={
        level distance=4cm, 
        sibling angle=120, 
        concept color=red!70, 
        font=\Large\bfseries
    },
    level 2 concept/.append style={
        level distance=3.5cm, 
        sibling angle=60, 
        concept color=orange!70,
        font=\large\sffamily
    },
    level 3 concept/.append style={
        level distance=3cm, 
        sibling angle=45, 
        concept color=green!70!black,
        font=\small\sffamily
    },
]

  % START OF TIKZ NODES GENERATED BY PYTHON
  % Level 0 node is the central node
  % Root Node is inserted here via string formatting
"""

TIKZ_END = r"""
  ; % End of the main node structure

\end{tikzpicture}

\vspace{0.5in}
\footnotesize
\textit{This mind map was generated from an indented text file using a Python script.}
"""

LATEX_END = r"""

\end{document}
"""

def generate_latex_table(data):
    """Generates the LaTeX longtable code from collected node data."""
    table_lines = [
        r"\newpage", # Start the table on a new page for readability
        r"\section*{Mind Map Node Descriptions}",
        r"{\centering",
        r"\begin{longtable}{@{} p{0.3\textwidth} p{0.6\textwidth} @{}}",
        r"    \caption{Node Details and Descriptions} \label{tab:node_details} \\",
        r"    \toprule",
        r"    \textbf{Node Name} & \textbf{Description} \\",
        r"    \midrule",
        r"    \endfirsthead",
        r"",
        r"    \multicolumn{2}{c}",
        r"    {\normalfont\textbf{\tablename~\thetable\ -- continued}} \\",
        r"    \toprule",
        r"    \textbf{Node Name} & \textbf{Description} \\",
        r"    \midrule",
        r"    \endhead"
    ]
    
    for item in data:
        # Escape critical LaTeX characters
        node_name = item['node'].replace('\\', r'\textbackslash ').replace('&', r'\&').replace('%', r'\%').replace('_', r'\_')
        description = item['desc'].replace('\\', r'\textbackslash ').replace('&', r'\&').replace('%', r'\%').replace('_', r'\_')
        
        table_lines.append(f"    {node_name} & {description} \\\\")
        table_lines.append(r"    \midrule") # Separator line
    
    table_lines.append(r"    \bottomrule")
    table_lines.append(r"\end{longtable}",)
    table_lines.append(r"}") # End centering
    
    return "\n" + "\n".join(table_lines) + "\n"

def get_indentation_level(line):
    """Calculates the indentation level based on spaces."""
    leading_spaces = len(line) - len(line.lstrip(' '))
    # Integer division to find the level
    return leading_spaces // INDENT_SPACES

def parse_line(line):
    """Extracts node name and description from a line."""
    full_text = line.strip()
    parts = full_text.split(' - ', 1)
    concept_text = parts[0].strip()
    description = parts[1].strip() if len(parts) > 1 else ""
    return concept_text, description

def generate_tikz_code(lines):
    """Reads the list of lines and generates the TikZ node structure and table data."""
    
    tikz_nodes = []
    table_data = [] # NEW: Data structure to hold node name and description for the table
    current_depth = 0 
    angle_index = 0
    
    if not lines:
        return "", "", "" # Return empty strings if no lines

    # --- 1. Process Root Node (Line 0) ---
    root_line = lines[0].rstrip()
    root_concept, root_description = parse_line(root_line)
    table_data.append({'node': root_concept, 'desc': root_description})
    
    # Generate the TikZ root node definition
    # We use a cleaner text format for the central node (Project \par Phases)
    root_node_definition = f"\n  \\node[concept] {{ \\textbf{{{root_concept.replace(' ', r'\\par ')}}}}}"

    # --- 2. Process Child Nodes (Lines 1 onwards) ---
    lines_to_process = lines[1:]

    for line in lines_to_process:
        line = line.rstrip() 
        if not line.strip():
            continue 

        depth = get_indentation_level(line)
        concept_text, description = parse_line(line)
        
        # Collect data for the table
        table_data.append({'node': concept_text, 'desc': description})
        
        # If we encounter a shallower level, close the previous child nodes
        if depth < current_depth:
            levels_to_pop = current_depth - depth
            tikz_nodes.append("  " * depth + "} " * levels_to_pop + "\n")
        
        # Determine the appropriate opening structure
        if depth > 0:
            # For Level 1, apply the custom grow angle
            if depth == 1:
                angle = LEVEL_1_ANGLES[angle_index % len(LEVEL_1_ANGLES)]
                tikz_nodes.append(f"  " * depth + f"child[grow={angle}] {{\n")
                angle_index += 1
            else:
                # For deeper levels, just use the standard child command
                tikz_nodes.append(f"  " * depth + "child {\n")
                
            # Add the concept node itself
            tikz_nodes.append(f"  " * (depth + 1) + f"\\node[concept] {{{concept_text}}}")
            
        current_depth = depth

    # After the loop, close any remaining open child nodes
    if current_depth > 0:
        tikz_nodes.append("} " * current_depth) 
        
    tikz_code_body = "".join(tikz_nodes)
    
    # Generate the table content
    latex_table = generate_latex_table(table_data)
    
    # Combine everything for the final document
    full_latex_document = (
        LATEX_START_TEMPLATE + 
        root_node_definition + 
        tikz_code_body + 
        TIKZ_END +
        latex_table + 
        LATEX_END
    )
    
    return full_latex_document

def main():
    """Main function to handle CLI arguments and perform I/O."""
    parser = argparse.ArgumentParser(
        description="Convert an indented text outline to a TikZ mind map LaTeX document.",
        epilog=f"Usage examples: \n  python {sys.argv[0]} -i input.txt -o output.tex\n  cat input.txt | python {sys.argv[0]} -i - -o -"
    )
    parser.add_argument('-i', '--input', type=str, default=INPUT_FILE,
                        help=f"Input file path (default: {INPUT_FILE}). Use '-' for standard input.")
    parser.add_argument('-o', '--output', type=str, default=OUTPUT_FILE,
                        help=f"Output file path (default: {OUTPUT_FILE}). Use '-' for standard output.")
    args = parser.parse_args()

    # --- Read Input ---
    input_lines = []
    if args.input == '-':
        print("Reading from standard input (stdin)...", file=sys.stderr)
        try:
            input_lines = sys.stdin.readlines()
        except Exception as e:
            print(f"Error reading from stdin: {e}", file=sys.stderr)
            sys.exit(1)
    else:
        try:
            with open(args.input, 'r') as f:
                print(f"Reading from file: {args.input}", file=sys.stderr)
                input_lines = f.readlines()
        except FileNotFoundError:
            print(f"Error: Input file '{args.input}' not found.", file=sys.stderr)
            sys.exit(1)
        except Exception as e:
            print(f"Error reading file '{args.input}': {e}", file=sys.stderr)
            sys.exit(1)

    # --- Generation ---
    if not input_lines:
        print("Warning: Input is empty. Generating an empty map.", file=sys.stderr)
        # Generate the boilerplate document without nodes or table
        full_latex_document = LATEX_START_TEMPLATE + '\n' + LATEX_END
    else:
        full_latex_document = generate_tikz_code(input_lines)

    # --- Write Output ---
    if args.output == '-':
        # Write directly to stdout
        sys.stdout.write(full_latex_document)
    else:
        try:
            with open(args.output, 'w') as f:
                f.write(full_latex_document)
            print(f"Successfully generated LaTeX document: {args.output}", file=sys.stderr)
        except IOError:
            print(f"Error: Could not write to output file '{args.output}'.", file=sys.stderr)
            sys.exit(1)

if __name__ == "__main__":
    main()